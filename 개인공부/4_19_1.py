import numpy as np

# π”Ή (1) κ°€μƒμ X(μ…λ ¥)μ™€ y(μ¶λ ¥)
# Xλ” mκ°μ μƒν”κ³Ό nκ°μ νΉμ„± (μ—¬κΈ°μ„  4μƒν”, 3νΉμ„±)
X = np.array([
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9],
    [2, 3, 4]
])
y = np.array([10, 20, 30, 12])  # μ •λ‹µκ°’ (1μ°¨μ› λ²΅ν„°)

# π”Ή (2) νλΌλ―Έν„° μ΄κΈ°ν™”
m, n = X.shape     # m: μƒν” μ, n: νΉμ„± μ
w = np.zeros(n)    # κ°€μ¤‘μΉ λ²΅ν„° w (nκ°)
b = 0.0            # μ νΈ b

# π”Ή (3) ν•μ΄νΌνλΌλ―Έν„°
lr = 0.01
epochs = 1000

# π”Ή (4) κ²½μ‚¬ν•κ°•λ²•
for epoch in range(epochs):
    # μμΈ΅κ°’ κ³„μ‚° (λ²΅ν„° λ‚΄μ  + μ νΈ)
    y_pred = np.dot(X, w) + b

    # μ¤μ°¨(loss) = μμΈ΅ - μ‹¤μ 
    error = y_pred - y

    # π”Έ μ†μ‹¤ ν•¨μ: ν‰κ·  μ κ³± μ¤μ°¨(MSE)
    loss = np.mean(error ** 2)

    # π”Έ κ²½μ‚¬(gradient) κ³„μ‚° (νΈλ―Έλ¶„ κ²°κ³Ό)
    dw = (2 / m) * np.dot(X.T, error)   # wμ— λ€ν• λ―Έλ¶„
    db = (2 / m) * np.sum(error)        # bμ— λ€ν• λ―Έλ¶„

    # π”Έ νλΌλ―Έν„° μ—…λ°μ΄νΈ (κΈ°μΈκΈ° λ°λ€λ°©ν–¥)
    w -= lr * dw
    b -= lr * db

    # π”Έ 100νλ§λ‹¤ μ†μ‹¤ μ¶λ ¥
    if epoch % 100 == 0:
        print(f"{epoch}λ²μ§Έ μ†μ‹¤: {loss:.4f}")

# π”Ή μµμΆ… κ²°κ³Ό μ¶λ ¥
print("\nμµμΆ… κ°€μ¤‘μΉ w:", w)
print("μµμΆ… μ νΈ b:", b)
